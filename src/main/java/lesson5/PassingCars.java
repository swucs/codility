package lesson5;

/**
 * N개의 정수로 구성된 비어 있지 않은 배열 A가 제공됩니다. 배열 A의 연속 요소는 도로의 연속 자동차를 나타냅니다.
 *
 * 배열 A에는 0 및/또는 1만 포함됩니다.
 *
 * 0은 동쪽으로 여행하는 자동차를 나타내고,
 * 1은 서쪽으로 여행하는 자동차를 나타냅니다.
 * 목표는 지나가는 자동차를 계산하는 것입니다. P가 동쪽으로 여행하고 Q가 서쪽으로 여행할 때 0 ≤ P < Q < N인 한 쌍의 자동차(P, Q)가 지나가고 있다고 말합니다.
 *
 * 예를 들어, 다음과 같은 배열 A를 고려하십시오.
 *
 *   A[0] = 0
 *   A[1] = 1
 *   A[2] = 0
 *   A[3] = 1
 *   A[4] = 1
 * (0, 1), (0, 3), (0, 4), (2, 3), (2, 4)의 다섯 쌍의 자동차가 지나가고 있습니다.
 *
 * 함수 작성:
 *
 * 클래스 솔루션 { 공개 int 솔루션(int[] A); }
 *
 * N 정수의 비어 있지 않은 배열 A가 주어지면 지나가는 자동차 쌍의 수를 반환합니다.
 *
 * 함수는 지나가는 자동차 쌍의 수가 1,000,000,000을 초과하면 -1을 반환해야 합니다.
 *
 * 예를 들면 다음과 같습니다.
 *
 *   A[0] = 0
 *   A[1] = 1
 *   A[2] = 0
 *   A[3] = 1
 *   A[4] = 1
 * 함수는 위에서 설명한 대로 5를 반환해야 합니다.
 *
 * 다음 가정에 대한 효율적인 알고리즘을 작성하십시오 .
 *
 * N은 [ 1 .. 100,000 ] 범위 내의 정수입니다 .
 * 배열 A의 각 요소는 0, 1 값 중 하나를 가질 수 있는 정수입니다.
 */

/**
   1을 찾고 그 위치 보다 작은 0을 찾아 sum한다.
    https://app.codility.com/demo/results/trainingQ7CEQ5-ZFH/    => 90%   함수는 지나가는 자동차 쌍의 수가 1,000,000,000을 초과하면 -1을 반환해야 합니다. 오류
    https://app.codility.com/demo/results/trainingYXWAW9-Y76/      => 100%
 */
public class PassingCars {
    public int solution(int[] A) {

        int sum = 0;
        int zeroCount = 0;
        for (int i = 0; i < A.length; i++) {
            if (A[i] == 0) {
                zeroCount++;
            } else {
                //1인 경우
                if ((sum + (long)zeroCount) > 1000000000l) {     //int를 넘어선 오버플로우가 발생하면 마이너스 값으로 변하므로 미리 체크할 필요가 있다.
                    return -1;
                }

                sum += zeroCount;
            }
        }


        return sum;
    }
}
